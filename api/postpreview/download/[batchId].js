import { SupabaseClient } from '../../../src/database/supabase-client.js';
import archiver from 'archiver';
import fetch from 'node-fetch';

const db = new SupabaseClient();

export default async function handler(req, res) {
  const { batchId } = req.query;

  if (req.method !== 'GET') {
    res.status(405).json({ error: 'Method not allowed' });
    return;
  }

  try {
    // Get batch data from database
    const { data: batch, error } = await db.client
      .from('preview_batches')
      .select('*')
      .eq('batch_id', batchId)
      .single();

    if (error || !batch) {
      res.status(404).json({ error: 'Batch not found' });
      return;
    }

    const posts = batch.posts_data;

    // Set headers for ZIP download
    res.setHeader('Content-Type', 'application/zip');
    res.setHeader('Content-Disposition', `attachment; filename="${batch.account_username}_${batchId}.zip"`);

    // Create ZIP archive
    const archive = archiver('zip', { zlib: { level: 9 } });
    archive.pipe(res);

    try {
      // Add images to ZIP
      for (const post of posts) {
        if (post.images && post.images.length > 0) {
          for (let i = 0; i < post.images.length; i++) {
            const image = post.images[i];
            try {
              console.log(`Fetching image: ${image.imagePath}`);
              const response = await fetch(image.imagePath);
              
              if (response.ok) {
                const buffer = await response.buffer();
                const extension = getFileExtension(image.imagePath) || '.jpg';
                const filename = `post_${post.postNumber}_image_${i + 1}${extension}`;
                archive.append(buffer, { name: filename });
              } else {
                console.warn(`Failed to fetch image: ${image.imagePath} (${response.status})`);
              }
            } catch (imageError) {
              console.error(`Error fetching image ${image.imagePath}:`, imageError.message);
            }
          }
        }
      }

      // Add captions and hashtags as text file
      const contentText = posts.map(post => {
        const imageList = post.images?.map((img, i) => 
          `  ${i + 1}. ${img.imagePath} (${img.aesthetic || 'No aesthetic'})`
        ).join('\n') || '  No images';

        return `POST ${post.postNumber}:
Caption: ${post.caption || 'No caption'}
Hashtags: ${post.hashtags?.join(' ') || 'No hashtags'}
Images: ${post.images?.length || 0}
Aesthetic: ${post.images?.[0]?.aesthetic || 'Mixed'}

Image Details:
${imageList}

---
`;
      }).join('\n');

      archive.append(contentText, { name: 'content_details.txt' });

      // Add batch metadata
      const metadata = `Content Batch Metadata
======================

Batch ID: ${batchId}
Account: @${batch.account_username}
Created: ${new Date(batch.created_at).toLocaleString()}
Total Posts: ${posts.length}
Total Images: ${batch.total_images}

Generated by easypost.fun Content Pipeline
Preview URL: https://easypost.fun/postpreview/${batchId}
`;

      archive.append(metadata, { name: 'batch_info.txt' });

      // Finalize the archive
      await archive.finalize();

    } catch (archiveError) {
      console.error('Archive creation error:', archiveError);
      if (!res.headersSent) {
        res.status(500).json({ error: 'Failed to create download archive' });
      }
    }

  } catch (error) {
    console.error('Download error:', error);
    if (!res.headersSent) {
      res.status(500).json({ error: error.message });
    }
  }
}

// Helper function to get file extension from URL
function getFileExtension(url) {
  try {
    const pathname = new URL(url).pathname;
    const lastDot = pathname.lastIndexOf('.');
    return lastDot !== -1 ? pathname.substring(lastDot) : null;
  } catch {
    // If URL parsing fails, try simple string matching
    const match = url.match(/\.(jpg|jpeg|png|gif|webp)(\?.*)?$/i);
    return match ? `.${match[1].toLowerCase()}` : null;
  }
} 